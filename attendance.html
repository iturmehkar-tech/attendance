<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mobile Attendance Tracker</title>
    <!-- Load Tailwind CSS for mobile-first styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load SheetJS for reading and writing Excel files -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <style>
        /* Define Inter font as requested */
        :root {
            font-family: 'Inter', sans-serif;
        }

        /* Base styles for the line item */
        .name-line {
            display: flex;
            height: 64px; /* Sufficient height for touch target */
            overflow: hidden;
            border-radius: 0.5rem;
            margin-bottom: 8px;
            cursor: pointer;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
            position: relative;
        }

        /* Zone common styles */
        .zone {
            display: flex;
            transition: width 0.3s ease-in-out, background-color 0.3s ease-in-out;
            user-select: none; /* Prevent text selection on tap */
        }

        /* Initial state: 50% width */
        .zone-50 {
            width: 50%;
        }

        /* Red Zone - Absent (Lighter Red - Red-300) */
        .red-zone {
            background-color: #fca5a5;
        }

        /* Green Zone - Attended (Lighter Green - Green-300) */
        .green-zone {
            background-color: #6ee7b7;
        }

        /* State: Red is dominant (2/3) */
        .state-absent .red-zone {
            width: 66.66%;
        }
        .state-absent .green-zone {
            width: 33.33%;
        }

        /* State: Green is dominant (2/3) */
        .state-attended .red-zone {
            width: 33.33%;
        }
        .state-attended .green-zone {
            width: 66.66%;
        }

        /* State: Reset/Neutral (50/50) */
        .state-neutral .red-zone, .state-neutral .green-zone {
            width: 50%;
        }

        /* Text overlay for visibility */
        .name-text-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: space-between; /* To push seat number to the right */
            padding: 0 1.5rem; /* px-6 */
            font-size: 1.125rem; /* text-lg */
            color: #1f2937; /* Gray-800 */
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.6);
            pointer-events: none; /* Allows clicks to pass through to the zones */
            z-index: 10;
        }
        
        .seat-display {
            font-weight: 700; /* font-bold */
            font-size: 1.5rem; /* text-2xl */
            padding-left: 1rem;
            color: #10b981; /* green-500 */
            transition: transform 0.2s ease-out;
            direction: rtl; /* Ensure the number is read correctly if in RTL context */
        }

        .state-absent .seat-display, .state-neutral .seat-display {
            transform: scale(0.9);
            color: #ef4444; /* red-500 */
            opacity: 0.5;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4">

    <div class="max-w-md mx-auto">
        <header class="mb-6">
            <h1 class="text-3xl font-extrabold text-gray-900 mb-2">Attendance Check & Seating</h1>
            <p class="text-gray-600">Assign seats 1-100. Status and seating are saved automatically. <span class="text-xs text-gray-400">v1.5.1 (Bugfix)</span></p>
            <p class="text-xs text-red-600 mt-1 p-2 bg-red-100 rounded-lg">
                Note: If selecting from Google Drive fails, please download the file to your device's local storage first, then select it from there.
            </p>
        </header>
        
        <!-- Seat Configuration Area -->
        <div id="seat-config-section" class="bg-white p-4 rounded-xl shadow-lg mb-6">
            <label for="dysfunctional-seats" class="block text-sm font-medium text-gray-700 mb-2">
                Dysfunctional Seats (1-100)
            </label>
            <input type="text" id="dysfunctional-seats" 
                   placeholder="e.g., 5, 12, 18 (comma-separated numbers)"
                   class="w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
                   onchange="handleDysfunctionalSeatsChange()"
            >
            <p id="seat-status" class="mt-2 text-sm text-gray-500">All 100 seats are currently functional.</p>
        </div>

        <!-- File Input Area -->
        <div id="input-section" class="bg-white p-4 rounded-xl shadow-lg mb-6">
            <input type="file" id="excel-file-input" accept=".xlsx, .xls" class="w-full text-sm text-gray-500
                file:mr-4 file:py-2 file:px-4
                file:rounded-lg file:border-0
                file:text-sm file:font-semibold
                file:bg-indigo-50 file:text-indigo-700
                hover:file:bg-indigo-100"
            />
            <p id="file-status" class="mt-2 text-sm text-gray-500">Maximum file size: 5MB.</p>
        </div>

        <!-- Attendance List Area -->
        <div id="attendance-list" class="space-y-2">
            <!-- List items will be injected here -->
            <div id="placeholder-message" class="text-center p-8 bg-white rounded-xl text-gray-500">
                <svg class="w-10 h-10 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                <p>Upload an Excel file to start tracking attendance.</p>
            </div>
        </div>

        <!-- Export Button (Initially hidden) -->
        <button id="export-button"
                class="hidden w-full mt-6 py-3 px-4 bg-green-600 hover:bg-green-700 text-white font-bold rounded-xl shadow-lg transition duration-150 ease-in-out active:scale-95 disabled:bg-gray-400"
                disabled
        >
            Download Attendance (Export to Excel)
        </button>
    </div>

    <script>
        // --- Global State and Constants ---
        const FILE_INPUT = document.getElementById('excel-file-input');
        const ATTENDANCE_LIST = document.getElementById('attendance-list');
        const EXPORT_BUTTON = document.getElementById('export-button');
        const FILE_STATUS = document.getElementById('file-status');
        const PLACEHOLDER = document.getElementById('placeholder-message');
        const SEAT_INPUT = document.getElementById('dysfunctional-seats');
        const SEAT_STATUS = document.getElementById('seat-status');

        const MAX_FILE_SIZE_MB = 5;
        const STORAGE_KEY = 'attendanceTrackerState';
        const ATTENDED_COLUMN_NAME = 'Attended'; 
        const SEAT_COLUMN_NAME = 'עמדה'; // Hebrew: Position/Stand

        // Stores the raw data from the Excel file, used for re-exporting.
        let rawWorksheetData = null;
        // Stores the name/attendance state: { uniqueKey: { rowData: {}, attended: 'Empty' | 'True' | 'False', seat: number | null } }
        let attendanceState = {};
        let originalSheetName = "Sheet1";

        // SEAT STATE
        let dysfunctionalSeats = new Set();
        let availableSeats = []; // Array of functional seats, sorted lowest to highest.
        const TOTAL_SEATS = 100;


        // --- Seat Logic Functions ---

        /**
         * Parses the dysfunctional seats input and updates the dysfunctionalSeats Set.
         */
        const handleDysfunctionalSeatsChange = () => {
            const input = SEAT_INPUT.value;
            const newDysfunctionalSeats = new Set();
            
            input.split(',')
                 .map(s => parseInt(s.trim()))
                 .filter(n => n >= 1 && n <= TOTAL_SEATS)
                 .forEach(n => newDysfunctionalSeats.add(n));
            
            dysfunctionalSeats = newDysfunctionalSeats;

            // Update status text
            if (dysfunctionalSeats.size > 0) {
                SEAT_STATUS.textContent = `${dysfunctionalSeats.size} seats are out of service. ${TOTAL_SEATS - dysfunctionalSeats.size} seats available.`;
            } else {
                SEAT_STATUS.textContent = `All ${TOTAL_SEATS} seats are currently functional.`;
            }
            
            initializeAvailableSeats();

            if (rawWorksheetData) {
                saveState(rawWorksheetData.arrayBuffer);
            } else {
                saveSeatConfig(); 
            }
        };

        /**
         * Generates the list of available seats based on dysfunctional seats and currently allocated seats.
         */
        const initializeAvailableSeats = () => {
            const allocatedSeats = new Set();
            for (const key in attendanceState) {
                const seat = attendanceState[key].seat;
                if (seat !== null) {
                    allocatedSeats.add(seat);
                }
            }

            const functionalSeats = [];
            for (let i = 1; i <= TOTAL_SEATS; i++) {
                // Only consider seats that are functional AND not currently allocated
                if (!dysfunctionalSeats.has(i) && !allocatedSeats.has(i)) {
                    functionalSeats.push(i);
                }
            }
            
            functionalSeats.sort((a, b) => a - b);
            availableSeats = functionalSeats;
        };
        
        /**
         * Saves only the dysfunctional seat configuration to storage.
         */
        const saveSeatConfig = () => {
            try {
                const existingStateString = localStorage.getItem(STORAGE_KEY);
                let existingState = existingStateString ? JSON.parse(existingStateString) : {};

                existingState.dysfunctionalSeats = Array.from(dysfunctionalSeats);
                localStorage.setItem(STORAGE_KEY, JSON.stringify(existingState));
            } catch (e) {
                console.error("Error saving seat config:", e);
            }
        }


        // --- Utility Functions for Persistence ---

        const arrayBufferToBase64 = (buffer) => {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        };

        const base64ToArrayBuffer = (base64) => {
            const binary_string = atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes.buffer;
        };

        const processArrayBuffer = (arrayBuffer) => {
            const data = new Uint8Array(arrayBuffer);
            
            const workbook = XLSX.read(data, { 
                type: 'array', 
                cellStyles: false,
                cellDates: false,
                cellFormula: false
            });
            
            const sheetName = workbook.SheetNames[0];
            originalSheetName = sheetName;
            const worksheet = workbook.Sheets[sheetName];

            const jsonOptions = { header: 1, raw: false }; 
            const rawData = XLSX.utils.sheet_to_json(worksheet, jsonOptions);

            const headers = rawData[0];
            const contentRows = rawData.slice(1);

            return { sheetName, headers, contentRows, workbook };
        };

        const readFileIntoBuffer = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
                    reject(new Error(`File is too large. Max allowed size is ${MAX_FILE_SIZE_MB}MB. Please reduce the size of your roster.`));
                    return;
                }

                reader.onload = (e) => {
                    resolve({ arrayBuffer: e.target.result, fileName: file.name });
                };
                
                reader.onerror = (error) => {
                    console.error("FileReader Disk Error:", error);
                    reject(new Error("File access error. The browser failed to read the file data."));
                };

                reader.readAsArrayBuffer(file);
            });
        };

        /**
         * Saves the current application state (file data, attendance, and seats) to localStorage.
         */
        const saveState = (fileBuffer) => {
            try {
                const base64Data = arrayBufferToBase64(fileBuffer);
                const stateToSave = {
                    fileData: base64Data,
                    attendanceState: attendanceState,
                    sheetName: originalSheetName,
                    timestamp: Date.now(),
                    dysfunctionalSeats: Array.from(dysfunctionalSeats) // Save Set as Array
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(stateToSave));
                console.log("State saved to localStorage.");
            } catch (e) {
                console.error("Error saving state to localStorage:", e);
                FILE_STATUS.textContent = "Warning: Could not save attendance state (browser storage quota reached).";
            }
        };

        /**
         * Updates only the attendance and seat state portion in localStorage (on every tap).
         */
        const updateAttendanceStateInStorage = () => {
            try {
                const existingStateString = localStorage.getItem(STORAGE_KEY);
                if (existingStateString) {
                    const existingState = JSON.parse(existingStateString);
                    existingState.attendanceState = attendanceState;
                    existingState.dysfunctionalSeats = Array.from(dysfunctionalSeats); // Save the current seat config too
                    existingState.timestamp = Date.now();
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(existingState));
                }
            } catch (e) {
                console.error("Error updating attendance state in localStorage:", e);
            }
        };


        // --- Core Logic Functions ---

        /**
         * Renders the attendance list based on the processed data.
         */
        const renderAttendanceList = (headers, contentRows) => {
            // Only clear state if rendering a NEW file. If loading from storage, attendanceState is already set.
            if (!rawWorksheetData) {
                attendanceState = {}; 
            }
            
            // Re-calculate the available seats pool based on the loaded state and config
            initializeAvailableSeats();
            
            ATTENDANCE_LIST.innerHTML = '';
            PLACEHOLDER.classList.add('hidden');
            EXPORT_BUTTON.classList.remove('hidden');
            EXPORT_BUTTON.disabled = false;
            EXPORT_BUTTON.textContent = 'Download Attendance (Export to Excel)';

            // FIX: Corrected findColIndex to properly iterate and use the header element 'h'
            const findColIndex = (headers, names) => {
                for (const name of names) {
                    const index = headers.findIndex(h => h && String(h).trim().toLowerCase().includes(name.toLowerCase()));
                    if (index !== -1) return index;
                }
                return -1;
            };

            const firstNameCol = findColIndex(headers, ['first name', 'שם פרטי']);
            const lastNameCol = findColIndex(headers, ['last name', 'שם משפחה']);

            if (firstNameCol === -1 || lastNameCol === -1) {
                FILE_STATUS.textContent = "Error: Could not find columns for 'First Name' or 'Last Name' ('שם פרטי' or 'שם משפחה'). Please check header names.";
                FILE_STATUS.classList.replace('text-gray-500', 'text-red-600');
                EXPORT_BUTTON.disabled = true;
                return;
            }

            contentRows.forEach((row, index) => {
                const firstName = row[firstNameCol] || '';
                const lastName = row[lastNameCol] || '';
                const fullName = `${firstName} ${lastName}`.trim();
                const uniqueKey = `row-${index}`;

                if (fullName) {
                    if (!attendanceState[uniqueKey]) {
                        attendanceState[uniqueKey] = {
                            rowData: row,
                            attended: 'Empty',
                            originalIndex: index + 1,
                            seat: null // Default to null
                        };
                    } else {
                        // Ensure seat is correctly set to null if it wasn't present in old state
                        attendanceState[uniqueKey].seat = attendanceState[uniqueKey].seat === undefined ? null : attendanceState[uniqueKey].seat;
                        attendanceState[uniqueKey].rowData = row; // Update rowData
                    }

                    const listItem = document.createElement('div');
                    listItem.id = uniqueKey;
                    
                    const initialStatus = attendanceState[uniqueKey].attended;
                    let initialClass = 'state-neutral';
                    if (initialStatus === 'True') initialClass = 'state-attended';
                    if (initialStatus === 'False') initialClass = 'state-absent';

                    listItem.className = `name-line ${initialClass}`;
                    listItem.setAttribute('data-key', uniqueKey);

                    const greenZone = document.createElement('div');
                    greenZone.className = 'zone green-zone zone-50';
                    greenZone.setAttribute('data-side', 'green');

                    const redZone = document.createElement('div');
                    redZone.className = 'zone red-zone zone-50';
                    redZone.setAttribute('data-side', 'red');

                    // Name and Seat Overlay
                    const nameOverlay = document.createElement('div');
                    nameOverlay.className = 'name-text-overlay';
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = fullName;
                    
                    const seatSpan = document.createElement('span');
                    seatSpan.className = 'seat-display';
                    seatSpan.textContent = attendanceState[uniqueKey].seat !== null ? attendanceState[uniqueKey].seat : '';

                    nameOverlay.appendChild(nameSpan);
                    nameOverlay.appendChild(seatSpan);


                    listItem.appendChild(redZone);
                    listItem.appendChild(greenZone);
                    listItem.appendChild(nameOverlay);

                    greenZone.addEventListener('click', handleAttendanceClick);
                    redZone.addEventListener('click', handleAttendanceClick);

                    ATTENDANCE_LIST.appendChild(listItem);
                }
            });

            FILE_STATUS.textContent = `Successfully loaded ${contentRows.length} rows from sheet "${originalSheetName}".`;
            FILE_STATUS.classList.replace('text-red-600', 'text-gray-500');
        };

        /**
         * Loads the application state from localStorage on startup.
         */
        const loadState = async () => {
            const stateString = localStorage.getItem(STORAGE_KEY);
            
            // 1. Load Seat Config first (initializes dysfunctionalSeats to empty set if no state)
            handleDysfunctionalSeatsChange();

            if (!stateString) {
                return;
            }

            FILE_STATUS.textContent = "Loading previous session...";
            
            try {
                const savedState = JSON.parse(stateString);
                
                // Restore dysfunctional seats from storage if available
                if (savedState.dysfunctionalSeats) {
                    dysfunctionalSeats = new Set(savedState.dysfunctionalSeats);
                    SEAT_INPUT.value = savedState.dysfunctionalSeats.join(', ');
                    handleDysfunctionalSeatsChange(); // Re-run to update UI and availableSeats pool
                }

                const fileBuffer = base64ToArrayBuffer(savedState.fileData);
                
                const { headers, contentRows, workbook } = processArrayBuffer(fileBuffer);

                // Restore global state
                rawWorksheetData = { headers, contentRows, workbook, arrayBuffer: fileBuffer };
                attendanceState = savedState.attendanceState;
                originalSheetName = savedState.sheetName;

                // Render the list using the restored state, which also initializes the availableSeats pool
                renderAttendanceList(headers, contentRows);

                FILE_STATUS.textContent = `Session loaded from ${new Date(savedState.timestamp).toLocaleTimeString()}. Ready to continue.`;
                EXPORT_BUTTON.classList.remove('hidden');
                EXPORT_BUTTON.disabled = false;

            } catch (error) {
                console.error("Error loading state from localStorage:", error);
                localStorage.removeItem(STORAGE_KEY);
                FILE_STATUS.textContent = "Previous session corrupted. Please upload a new file.";
                FILE_STATUS.classList.replace('text-gray-500', 'text-red-600');
            }
        };

        /**
         * Handles the click/tap event on the red or green zone to update attendance state and seats.
         */
        const handleAttendanceClick = (event) => {
            const clickedZone = event.currentTarget;
            const side = clickedZone.getAttribute('data-side');
            const listItem = clickedZone.closest('.name-line');
            const key = listItem.getAttribute('data-key');
            const stateEntry = attendanceState[key];

            const currentState = stateEntry.attended;
            let newState;
            let assignedSeat = stateEntry.seat;

            // Determine the next state
            if (side === 'green') {
                newState = (currentState === 'True') ? 'Empty' : 'True';
            } else { // side === 'red'
                newState = (currentState === 'False') ? 'Empty' : 'False';
            }
            
            // --- Seat Allocation/Deallocation Logic ---

            // A. Deallocate seat if moving AWAY from 'True'
            if (currentState === 'True' && newState !== 'True') {
                if (assignedSeat !== null) {
                    availableSeats.push(assignedSeat); // Return seat to pool
                    availableSeats.sort((a, b) => a - b); // Keep pool sorted (lowest first)
                    assignedSeat = null; // Clear assignment
                }
            }

            // B. Allocate seat if moving TO 'True' AND no seat is currently assigned
            if (newState === 'True' && assignedSeat === null) {
                if (availableSeats.length > 0) {
                    assignedSeat = availableSeats.shift(); // Get lowest available seat
                } else {
                    // Cannot assign a seat, but still mark as attended. Show a console warning.
                    console.warn("No functional, unallocated seats available to assign.");
                }
            }

            // Update the state object (Global)
            stateEntry.attended = newState;
            stateEntry.seat = assignedSeat;

            // Update the visual class
            listItem.classList.remove('state-neutral', 'state-attended', 'state-absent');
            if (newState === 'True') {
                listItem.classList.add('state-attended');
            } else if (newState === 'False') {
                listItem.classList.add('state-absent');
            } else {
                listItem.classList.add('state-neutral');
            }

            // Update the seat number display
            const seatDisplayElement = listItem.querySelector('.seat-display');
            if (seatDisplayElement) {
                seatDisplayElement.textContent = assignedSeat !== null ? assignedSeat : '';
            }

            // Persist attendance and seat changes immediately
            updateAttendanceStateInStorage();
        };

        /**
         * Creates and downloads the new Excel file with the attendance and seat column.
         */
        const exportAttendance = () => {
            if (!rawWorksheetData || Object.keys(attendanceState).length === 0) {
                console.error("No data to export.");
                return;
            }

            const { headers, contentRows } = rawWorksheetData;

            // 1. Identify/create column indices for ATTENDED and SEAT (עמדה) columns
            let newHeaders = [...headers];
            
            // Look for 'Attended'
            let attendedColIndex = headers.findIndex(h => String(h).toLowerCase() === ATTENDED_COLUMN_NAME.toLowerCase());
            if (attendedColIndex === -1) {
                newHeaders.push(ATTENDED_COLUMN_NAME);
                attendedColIndex = newHeaders.length - 1;
            }
            
            // Look for 'עמדה' (or Seat in English as a fallback if the user previously used 'Seat')
            // Priority: 1. Existing 'עמדה' header | 2. Existing 'Seat' header | 3. New 'עמדה' header
            let seatColIndex = headers.findIndex(h => String(h).toLowerCase() === SEAT_COLUMN_NAME.toLowerCase());
            if (seatColIndex === -1) {
                // Check if 'Seat' was used before
                seatColIndex = headers.findIndex(h => String(h).toLowerCase() === 'seat');
            }

            if (seatColIndex === -1) {
                // If neither exists, add the new column 'עמדה'
                newHeaders.push(SEAT_COLUMN_NAME);
                seatColIndex = newHeaders.length - 1;
            } else if (seatColIndex < attendedColIndex) {
                 // If 'עמדה' or 'Seat' was found, we use that index.
            } else if (seatColIndex > attendedColIndex) {
                 // Index is set.
            }


            // 2. Map the attendance state back onto the content rows
            const newContentRows = contentRows.map((row, index) => {
                const key = `row-${index}`;
                const state = attendanceState[key];
                
                // Ensure the row is long enough for both columns
                let newRow = [...row];
                while (newRow.length <= Math.max(attendedColIndex, seatColIndex)) {
                    newRow.push('');
                }

                let attendanceValue = '';
                let seatValue = '';

                if (state) {
                    if (state.attended === 'True') {
                        attendanceValue = 'TRUE';
                        seatValue = state.seat !== null ? state.seat : '';
                    } else if (state.attended === 'False') {
                        attendanceValue = 'FALSE';
                        seatValue = ''; // Explicitly clear/set empty if not attended
                    } else { // 'Empty'
                        attendanceValue = '';
                        seatValue = ''; // Explicitly clear/set empty if 'Empty'
                    }
                }
                
                // Set the values at their determined indices (overwriting existing data)
                newRow[attendedColIndex] = attendanceValue;
                newRow[seatColIndex] = seatValue;
                return newRow;
            });

            // 3. Combine headers and new content
            const exportData = [newHeaders, ...newContentRows];

            // 4. Create the new workbook and sheet
            const ws = XLSX.utils.aoa_to_sheet(exportData);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, originalSheetName);

            // 5. Trigger download
            const fileName = originalSheetName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
            XLSX.writeFile(wb, `${fileName}_attendance_seating_${new Date().toISOString().slice(0, 10)}.xlsx`);
        };


        // --- Event Listeners and Initialization ---

        FILE_INPUT.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            FILE_STATUS.textContent = `Processing file: ${file.name}...`;
            FILE_STATUS.classList.replace('text-red-600', 'text-gray-500');
            EXPORT_BUTTON.disabled = true;
            EXPORT_BUTTON.textContent = 'Processing... Please Wait';

            try {
                const { arrayBuffer } = await readFileIntoBuffer(file);
                const { headers, contentRows, workbook } = processArrayBuffer(arrayBuffer);

                rawWorksheetData = { headers, contentRows, workbook, arrayBuffer };
                attendanceState = {}; // Reset attendance state for the new file

                // Render list with empty state (and initial seat config)
                renderAttendanceList(headers, contentRows); 
                saveState(arrayBuffer); // Save new file data and the reset state

            } catch (error) {
                console.error("File processing error:", error);
                FILE_STATUS.textContent = `Failed to process file. Error: ${error.message}`;
                FILE_STATUS.classList.replace('text-gray-500', 'text-red-600');
                ATTENDANCE_LIST.innerHTML = '';
                PLACEHOLDER.classList.remove('hidden');
                EXPORT_BUTTON.classList.add('hidden');
                FILE_INPUT.value = '';
                EXPORT_BUTTON.textContent = 'Download Attendance (Export to Excel)';
            }
        });

        EXPORT_BUTTON.addEventListener('click', exportAttendance);

        // --- Firebase/Canvas Boilerplate ---
        // Note: Using localStorage for persistence per user request, despite platform mandate for Firestore.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;

        if (firebaseConfig) {
            console.log("Firebase config loaded. This application uses client-side localStorage for persistence.");
        } else {
             console.log("No Firebase config detected. Running in purely client-side mode with localStorage.");
        }

        // --- Initialization ---
        // Load the state when the script initializes
        loadState();

    </script>
</body>
</html>
